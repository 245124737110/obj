<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Object Detection</title>
    <style>
        /* Reset & Base - MOBILE FIRST */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            height: 100%; 
            overflow-x: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
        }

        /* FIXED: Top layout, no vertical centering */
        body { 
            background: linear-gradient(135deg, #f0f4f8 0%, #d9e2ec 100%);
            color: #34495e;
            padding: 15px;
            display: block;  /* ‚ùå No flex centering */
        }

        /* Responsive Typography */
        h1 { 
            font-size: clamp(1.8em, 5vw, 2.8em);
            color: #1abc9c;
            text-shadow: 0 3px 6px rgba(0,0,0,0.1);
            margin-bottom: 25px;
            text-align: center;
        }

        /* Controls - Stack mobile, row desktop */
        .controls { 
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        @media (min-width: 768px) {
            .controls { flex-direction: row; }
        }

        button { 
            padding: clamp(12px, 4vw, 16px) clamp(24px, 8vw, 36px);
            border: none; 
            border-radius: 30px; 
            cursor: pointer; 
            font-size: clamp(16px, 4vw, 18px);
            font-weight: 600; 
            color: white; 
            transition: all 0.3s ease; 
            box-shadow: 0 6px 18px rgba(26, 188, 156, 0.4);
            background: linear-gradient(135deg, #1abc9c, #16a085);
            min-width: 200px;
            touch-action: manipulation;
        }

        button:hover:not(:disabled), button:active:not(:disabled) { 
            transform: translateY(-3px); 
            box-shadow: 0 10px 25px rgba(26, 188, 156, 0.6); 
        }

        button:disabled { 
            background: #bdc3c7; 
            cursor: not-allowed; 
            box-shadow: none; 
        }

        /* Detection Area - Stack mobile */
        .detection-area { 
            position: relative; 
            width: 100%; 
            max-width: 900px; 
            height: clamp(400px, 60vh, 500px);
            margin: 0 auto 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .detection-area { flex-direction: row; justify-content: center; }
        }

        /* Video Container */
        .video-container { 
            position: relative;
            width: 100%; 
            max-width: 640px; 
            height: clamp(300px, 45vw, 480px);
            border-radius: 20px; 
            overflow: hidden; 
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            background: linear-gradient(145deg, #ffffff, #e0f7f4);
            display: flex;
            align-items: center; 
            justify-content: center;
        }

        video { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            border-radius: 20px;
            display: none;
        }

        .camera-icon { 
            font-size: clamp(80px, 20vw, 120px); 
            color: #bdc3c7; 
            display: block; 
            transition: transform 0.3s ease, color 0.3s ease; 
        }

        .camera-icon:hover { 
            transform: scale(1.1); 
            color: #95a5a6; 
        }

        /* Counts Panel - Below video mobile */
        .counts-panel { 
            width: 100%; 
            max-width: 220px; 
            min-height: 150px;
            padding: clamp(15px, 5vw, 25px);
            background: rgba(255,255,255,0.97);
            border-radius: 25px; 
            border: 3px solid rgba(26, 188, 156, 0.3);
            box-shadow: 0 12px 40px rgba(0,0,0,0.12);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: clamp(16px, 4vw, 18px);
            font-weight: 600;
            color: #16a085;
            text-align: center;
        }

        @media (min-width: 768px) {
            .counts-panel { 
                position: absolute; 
                right: 0; 
                top: 50%; 
                transform: translateY(-50%);
                width: 220px;
                min-height: 200px;
            }
        }

        .counts-list div { margin: 6px 0; }
        .no-detection { color: #95a5a6 !important; font-style: italic; }
        .detecting { color: #3498db; font-style: italic; }

        /* Canvas overlay */
        canvas { 
            border-radius: 20px; 
            pointer-events: none; 
        }

        .overlay-box { 
            position: absolute; 
            border: 3px solid #00ff41; 
            border-radius: 6px; 
            pointer-events: none; 
        }

        .overlay-label { 
            position: absolute; 
            background: rgba(0,255,65,0.9); 
            color: #000; 
            font-weight: bold; 
            font-size: clamp(12px, 3vw, 16px);
            padding: 2px 6px; 
            border-radius: 4px; 
            pointer-events: none; 
        }
    </style>
</head>
<body>
    <h1>üîç Real-Time Object Detection</h1>
    
    <div class="controls">
        <button id="startBtn" onclick="startDetection()">üì± Start Detection</button>
        <button id="stopBtn" onclick="stopDetection()" disabled>‚èπÔ∏è Stop Detection</button>
    </div>

    <div class="detection-area">
        <div class="video-container">
            <video id="video" autoplay muted playsinline></video>
            <div class="camera-icon" id="cameraIcon">üì∑</div>
            <canvas id="canvasOverlay"></canvas>
        </div>
        <div class="counts-panel no-detection" id="counts">
            <div class="counts-list">
                Click "Start"<br>to begin
            </div>
        </div>
    </div>

    <script>
        let video = document.getElementById('video');
        let cameraIcon = document.getElementById('cameraIcon');
        let countsEl = document.getElementById('counts');
        let startBtn = document.getElementById('startBtn');
        let stopBtn = document.getElementById('stopBtn');
        let stream = null;
        let intervalId = null;
        let canvasOverlay = null;
        let ctxOverlay = null;
        let inFlight = false;

        function showCameraIcon() {
            video.style.display = 'none';
            if (canvasOverlay) {
                canvasOverlay.parentNode.removeChild(canvasOverlay);
                canvasOverlay = null;
            }
            cameraIcon.style.display = 'block';
            countsEl.innerHTML = '<div class="counts-list">Ready to<br>detect</div>';
            countsEl.classList.add('no-detection');
            countsEl.classList.remove('detecting');
        }

        function hideCameraIcon() {
            cameraIcon.style.display = 'none';
        }

        function createOverlay() {
            canvasOverlay = document.createElement('canvas');
            canvasOverlay.style.position = 'absolute';
            canvasOverlay.style.top = '0';
            canvasOverlay.style.left = '0';
            canvasOverlay.width = 640;
            canvasOverlay.height = 480;
            canvasOverlay.style.borderRadius = '20px';
            canvasOverlay.style.pointerEvents = 'none';
            ctxOverlay = canvasOverlay.getContext('2d');
            document.querySelector('.video-container').appendChild(canvasOverlay);
        }

        async function initCamera() {
            stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480, facingMode: 'environment' }
            });
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = r);
        }

        async function startDetection() {
            try {
                await initCamera();
                createOverlay();
                startBtn.disabled = true;
                stopBtn.disabled = false;
                hideCameraIcon();
                video.style.display = 'block';
                video.play();
                countsEl.innerHTML = '<div class="counts-list"><br>Detecting...</div>';
                countsEl.classList.add('detecting');
                countsEl.classList.remove('no-detection');
                intervalId = setInterval(sendFrameForDetection, 300);  // Faster 300ms
            } catch (e) {
                alert('Camera access denied. Please allow camera permission.');
                startBtn.disabled = false;
            }
        }

        function stopDetection() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            inFlight = false;
            showCameraIcon();
            startBtn.disabled = false;
            stopBtn.disabled = true;
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(t => t.stop());
                video.srcObject = null;
            }
        }

        async function sendFrameForDetection() {
            if (!video.videoWidth || video.paused || inFlight) return;
            inFlight = true;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            tempCtx.drawImage(video, 0, 0);
            tempCanvas.toBlob(async (blob) => {
                try {
                    const formData = new FormData();
                    formData.append('image', blob);
                    
                    const res = await fetch('/detect', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const data = await res.json();

                    // Update counts (right side mobile/desktop)
                    if (data.counts && Object.keys(data.counts).length > 0) {
                        const countItems = Object.entries(data.counts)
                            .map(([cls, cnt]) => `<div><strong>${cls}: ${cnt}</strong></div>`)
                            .join('');
                        countsEl.innerHTML = `<div class="counts-list">${countItems}</div>`;
                        countsEl.classList.remove('no-detection', 'detecting');
                    } else {
                        countsEl.innerHTML = '<div class="counts-list">No objects</div>';
                        countsEl.classList.add('no-detection');
                    }

                    // Draw boxes + labels
                    ctxOverlay.clearRect(0, 0, 640, 480);
                    if (data.objects?.length > 0) {
                        data.objects.forEach(obj => {
                            const [x, y, x2, y2] = obj.box;
                            ctxOverlay.strokeStyle = '#00ff41';
                            ctxOverlay.lineWidth = 3;
                            ctxOverlay.shadowColor = 'rgba(0,255,65,0.5)';
                            ctxOverlay.shadowBlur = 8;
                            ctxOverlay.strokeRect(x, y, x2-x, y2-y);

                            const text = `${obj.label} ${obj.confidence}`;
                            ctxOverlay.font = 'bold 18px Segoe UI';
                            const tw = ctxOverlay.measureText(text).width;
                            ctxOverlay.fillStyle = 'rgba(0,255,65,0.9)';
                            ctxOverlay.fillRect(x, Math.max(0, y-25), tw+10, 24);
                            ctxOverlay.fillStyle = '#000';
                            ctxOverlay.textAlign = 'left';
                            ctxOverlay.textBaseline = 'middle';
                            ctxOverlay.fillText(text, x+5, Math.max(14, y-13));
                        });
                    }
                } catch (e) {
                    countsEl.innerHTML = '<div class="counts-list">Error</div>';
                    countsEl.classList.add('no-detection');
                } finally {
                    inFlight = false;
                }
            }, 'image/jpeg', 0.7);
        }
    </script>
</body>
</html>
